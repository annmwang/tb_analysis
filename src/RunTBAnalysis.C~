///
///  \file   RunTBAnalysis.C
///
///  \author A. Wang, based on C. Rogan
///
///  \date   25 April 2018
///

#include "TH1D.h"
#include "TH2D.h"
#include <iostream>

#include "include/PDOToCharge.hh"
#include "include/TDOToTime.hh"
#include "include/MMDataAnalysis.hh"
#include "include/MMRunProperties.hh"
#include "include/MMPacmanAlgo.hh"
//#include "include/GeoOctuplet.hh"
//#include "include/SimpleTrackFitter.hh"

using namespace std;

int main(int argc, char* argv[]){

  char inputFileName[400];
  char outputFileName[400];
  char PDOFileName[400];
  char TDOFileName[400];
  
  if ( argc < 5 ){
    cout << "Error at Input: please specify input/output .root files ";
    cout << " and (optional) PDO/TDO calibration files" << endl;
    cout << "Example:   ./RunMMAnalysisTemplate.x -i input.root -o output.root" << endl;
    cout << "Example:   ./RunMMAnalysisTemplate.x -i input.root -o output.root";
    cout << " -p PDOcalib.root -t TDOcalib.root" << endl;
    return 0;
  }

  bool b_input = false;
  bool b_out   = false;
  bool b_pdo   = false;
  bool b_tdo   = false;
  for (int i=1;i<argc-1;i++){
    if (strncmp(argv[i],"-i",2)==0){
      sscanf(argv[i+1],"%s", inputFileName);
      b_input = true;
    }
    if (strncmp(argv[i],"-o",2)==0){
      sscanf(argv[i+1],"%s", outputFileName);
      b_out = true;
    }
    if (strncmp(argv[i],"-p",2)==0){
      sscanf(argv[i+1],"%s", PDOFileName);
      b_pdo = true;
    }
    if (strncmp(argv[i],"-t",2)==0){
      sscanf(argv[i+1],"%s", TDOFileName);
      b_tdo = true;
    }
  }

  if(!b_input){
    cout << "Error at Input: please specify input file (-i flag)" << endl;
    return 0;
  }

  if(!b_out){
    cout << "Error at Input: please specify output file (-o flag)" << endl;
    return 0;
  }


  // PDO calibration object
  PDOToCharge* PDOCalibrator;
  if(b_pdo)
    PDOCalibrator = new PDOToCharge(PDOFileName);
  else
    PDOCalibrator = new PDOToCharge();

  // TDO calibration object
  TDOToTime* TDOCalibrator;
  if(b_tdo)
    TDOCalibrator = new TDOToTime(TDOFileName);
  else
    TDOCalibrator = new TDOToTime();

  // clustering algorithm object
  MMPacmanAlgo* PACMAN = new MMPacmanAlgo();

  // data object
  MMDataAnalysis* DATA;
  TFile* f = new TFile(inputFileName, "READ");
  if(!f){
    cout << "Error: unable to open input file " << inputFileName << endl;
    return false;
  }
  TTree* T = (TTree*) f->Get("vmm");
  TTree* R = (TTree*) f->Get("run_properties");
  if(!T){
    cout << "Error: cannot find tree vmm in " << inputFileName << endl;
    return false;
  }

  if(!R){
    cout << "Error: cannot find tree run_properties in " << inputFileName << endl;
    return false;
  }

  MMRunProperties mm_RunProperties = MMRunProperties(R);                                     
  mm_RunProperties.GetEntry(0);                                                                                                    
  int m_RunNum = mm_RunProperties.runNumber;  
  DATA = (MMDataAnalysis*) new MMDataAnalysis(T, m_RunNum);

  int ibo = 0;
  int nboards = 2;
  std::map< string, TH1D* > h1;
  std::map< string, TH2D* > h2;
  
  h2["strip_position_vs_board"] = new TH2D("strip_position_vs_board", ";strip number;MMFE number;charge [fC]", 512, 0.5, 512.5, 8, -0.5, 7.5);

  for (ibo = 0; ibo < nboards; ibo++){
    h2[Form("strip_q_vs_ch_%i",    ibo)] = new TH2D(Form("strip_q_vs_ch_%i",    ibo), ";strip number;Charge [fC];strip",    512, 0.5, 512.5, 512,   0,  128);
    h2[Form("strip_pdo_vs_ch_%i",  ibo)] = new TH2D(Form("strip_pdo_vs_ch_%i",  ibo), ";strip number;PDO [counts];strip",   512, 0.5, 512.5, 512,   0, 2048);
    h2[Form("strip_tdo_vs_ch_%i",  ibo)] = new TH2D(Form("strip_tdo_vs_ch_%i",  ibo), ";strip number;TDO [counts];strip",   512, 0.5, 512.5, 256,   0,  256);
    h2[Form("strip_tdoc_vs_ch_%i", ibo)] = new TH2D(Form("strip_tdoc_vs_ch_%i", ibo), ";strip number;TDO corr. [ns];strip", 512, 0.5, 512.5, 110, -10,  100);
  }
  h1["tdo_gain"] = new TH1D("tdo_gain", "tdo_gain", 100,   0, 3);
  h1["tdo_ped"]  = new TH1D("tdo_ped",  "tdo_ped",  100, -10, 50);
  h1["pdo_gain"] = new TH1D("pdo_gain", "pdo_gain", 100,   0, 30);
  h1["pdo_ped"]  = new TH1D("pdo_ped",  "pdo_ped",  100, -100, 300);

  int Nevent = DATA->GetNEntries();

  // open output file
  TFile* fout = new TFile(outputFileName, "RECREATE");
  // set style for plotting

  for(int evt = 0; evt < Nevent; evt++){
    DATA->GetEntry(evt);
    if(evt%10000 == 0)
      cout << "Processing event # " << evt << " | " << Nevent << endl;

    // tell the octuplet geometry object
    // the run number if not already done

    // DATA->mm_EventHits (MMEventHits class) is the collection
    // of MM hits (MMHit class) for the event
    
    // Calibrate PDO -> Charge
    //PDOCalibrator->Calibrate(DATA->mm_EventHits);
    // Calibrate TDO -> Time
    //TDOCalibrator->Calibrate(DATA->mm_EventHits);
  
    // initialize PACMAN info for this event
    PACMAN->SetEventTrigBCID(-1);

    // how many duplicate hits in the event
    // (number of hits with at least 1 dup)
    int Ndup_evt = DATA->mm_EventHits.GetNDuplicates();
    
    // Loop through boards with hits in event
    int Nboard = DATA->mm_EventHits.GetNBoards();
    for(int i = 0; i < Nboard; i++){
      int Ndup_board = DATA->mm_EventHits[i].GetNDuplicates();
      
      // Loop through hits on the board
      int Nhit = DATA->mm_EventHits[i].GetNHits();
      for(int j = 0; j < Nhit; j++){
	double PDO  = DATA->mm_EventHits[i][j].PDO();
	double TDO  = DATA->mm_EventHits[i][j].TDO();
	double chan = DATA->mm_EventHits[i][j].Channel();
	// ... plus other methods - see include/MMHit.hh

	// can also grab a reference to a hit for easier
	// typing:
	auto hit = DATA->mm_EventHits[i][j];
	// how many duplicates are there for this hit?
	int Ndup_hit = hit.GetNHits();
        ibo = hit.MMFE8Index();
        h2[Form("strip_pdo_vs_ch_%i", ibo)]->Fill(hit.Channel(), hit.PDO());
        h2[Form("strip_tdo_vs_ch_%i", ibo)]->Fill(hit.Channel(), hit.TDO());
      }
    }
    continue;
    // a vector of lists of clusters
    vector<MMClusterList> all_clusters;
    for(int i = 0; i < Nboard; i++){
      // ignore empty boards
      if(DATA->mm_EventHits[i].GetNHits() == 0)
	continue;

      // cluster a board's collection of hits into clusters
      MMClusterList clusters = PACMAN->Cluster(DATA->mm_EventHits[i]);

      // if there's at least one cluster
      // in list save it 
      if(clusters.GetNCluster() > 0)
	all_clusters.push_back(clusters);
    }

    // how many non-empty cluster lists?
    int Ncl = all_clusters.size();
    for(int i = 0; i < Ncl; i++){
      // how many clusters in a list?
      int Nc = all_clusters[i].GetNCluster();
      for(int j = 0; j < Nc; j++){
	// get a reference to cluster [i][j]
	const MMCluster& clus = all_clusters[i][j];
	double Q  = clus.Charge();
	double T  = clus.Time();
	int Nhole = clus.NHoles();
	int Ndup_clus = clus.GetNDuplicates();
	// ....
      }
    }

    // track fitting
    MMClusterList fit_clusters;
    for(int i = 0; i < Ncl; i++){
      // add highest charge cluster from each board
      // (sorted by charge in MMClusterList)
      if(all_clusters[i].GetNCluster() > 0)
	fit_clusters.AddCluster(all_clusters[i][0]);
    }
  }
  fout->cd();
  fout->mkdir("histograms");
  fout->cd("histograms");

  for (auto kv: h1)
    kv.second->Write();
  for (auto kv: h2)
    kv.second->Write();
  fout->Close();
}
